---
title: "EDA"
author: "Lukáš Častven, Michal Kilian"
date: "`r Sys.Date()`"
output: html_document
---

# Predicting LoL game winner

League of Legends (LoL) is a 5v5 multiplayer online battle arena (MOBA) game.
Teams compete to destroy the enemy's base structure, the Nexus.

Our project goal is to predict the winning team based on events occurring within
the first `N` minutes of professional matches.

## Dataset

The dataset consists of three CSV files: `game_metadata.csv`, `game_players_stats.csv`,
and `game_events.csv`. The fields `game_id` and `player_id` link these files. Additionally
we found dataset `260225_LoL_champion_data.csv` containing metadata about champions,
which can be linked by the champion name.

### Source

The dataset contains detailed statistics and events from professional LoL matches (2019-2024).
It was published on
[IEEE DataPort under a CC license](https://ieee-dataport.org/documents/league-legends-esports-player-game-data-2019-2024). 
However, since IEEE is a greedy corporation, accessing it there requires a paid subscription.

We obtained the identical dataset directly from the authors' GitHub repository
([PandaScore/PandaSkill](https://github.com/PandaScore/PandaSkill)). This source
provides the data under the permissive MIT license.

The dataset containing metadata about champions up to February 2025, can be
found on Kaggle under name
[25.S1.4 League of Legends Champion Data (2025)](https://www.kaggle.com/datasets/laurenainsleyhaines/25-s1-4-league-of-legends-champion-data-2025/data).
The original dataset didn't include champion classifications like 'Fighter', 'Mage,
and we think it might help.

### `game_metadata.csv`

This file contains general information about each game.

*   `game_id`: Unique game identifier.
*   `date`: Game date and time in format YYYY-MM-DD HH:MM:SS.ssssss.
*   `match_id`: Identifier for the match (e.g., a best-of-5 series).
*   `tournament_id`: Unique tournament identifier.
*   `tournament_name`: Name of the tournament.
*   `series_id`: Unique series identifier.
*   `series_name`: Name of the series (e.g., LCK Summer 2024).
*   `league_id`: Unique league identifier.
*   `league_name`: Name of the league (e.g., LCK).
*   *Note:* Games belong to matches, matches to tournaments, tournaments to series, and series to leagues.

### `game_players_stats.csv`

This file provides player statistics at the end of each game.

*   `game_id`: Unique game identifier.
*   `player_id`: Unique player identifier.
*   `player_name`: Player's in-game name.
*   `team_id`: Unique team identifier.
*   `team_name`: Name of the player's team.
*   `team_acronym`: Team's acronym.
*   `role`: Player's role (e.g., Mid).
*   `win`: Binary indicator (1 if player won, 0 otherwise).
*   `game_length`: Duration of the game in seconds.
*   `champion_name`: Name of the champion played.
*   `team_kills`: Total champion kills by the player's team.
*   `tower_kills`: Total tower kills by the player's team.
*   `inhibitor_kills`: Total inhibitor kills by the player's team.
*   `dragon_kills`: Total dragon kills by the player's team.
*   `herald_kills`: Total Rift Herald kills by the player's team.
*   `baron_kills`: Total Baron Nashor kills by the player's team.
*   `player_kills`: Player's champion kills.
*   `player_deaths`: Player's deaths.
*   `player_assists`: Player's assists.
*   `total_minions_killed`: Player's minion kills (CS).
*   `gold_earned`: Player's total gold earned.
*   `level`: Player's final champion level.
*   `total_damage_dealt`: Player's total damage dealt.
*   `total_damage_dealt_to_champions`: Player's damage dealt to enemy champions.
*   `total_damage_taken`: Player's total damage taken.
*   `wards_placed`: Player's number of wards placed.
*   `largest_killing_spree`: Player's largest killing spree count.
*   `largest_multi_kill`: Player's largest multi-kill count (e.g., 2 for double kill).

### `game_events.csv`

This file contains specific events occurring during each game.

*   `game_id`: Unique game identifier.
*   `timestamp`: Time in seconds when the event occurred.
*   `event_type`: Type of event (e.g., `player_kill`, `drake_kill`).
*   `killer_id`: ID of the player who got the kill (if applicable).
*   `killed_id`: ID of the player/unit killed (if applicable).
*   `assisting_player_ids`: List of IDs of assisting players (for kills).
*   `drake_type`: Type of dragon killed (e.g., infernal, cloud).

### `260225_LoL_champion_data.csv`

This file contains metadata about champions up to February 2025, we only want
the name and it's type.

*	`first column`: Name of the champion.
*	`herotype`: What type is the champion.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())

library(tidyverse)
library(tidymodels)
library(patchwork)
library(corrplot)
library(scales)
library(ggmosaic)
source("./dataset.R")

metadata <- read_csv("data/game_metadata.csv", show_col_types = F)
player_stats <- read_csv("data/game_players_stats.csv", show_col_types = F)
events <- read_csv("data/game_events.csv", show_col_types = F)
champs <- read_csv("data/260225_LoL_champion_data.csv", show_col_types = F) %>%
	rename(name = `...1`) 

color1 <- "plum"
color2 <- "#A0DDA1"
```

## Hypothesis

We hypothesize that if a team has more advantages in early game
(events that happen before `N`th minute), then they are more likely to win the
whole game. We want to classify, based on early games state, if team 1 will
win or loose.

## Representing early game state

We will create features representing the relative advantage between the two teams at the
`N` minute. This involves calculating the difference in key objectives (kills,
dragons, heralds, towers) and identifying which team secured the first
significant event (first blood, first dragon, first herald) with timestamps of
these events. Also We will calculate differences in champion types for each team.

### Steps

1. Filter raw player statistics to select games with complete data (10 players, 2 distinct teams). 
2. Identify `team1_id` (numerically lower ID) and `team2_id` (numerically higher ID) for each valid game.
3. Create the target variable `team1_won` (1 if team 1 won, 0 otherwise) based on player win status.
4. Build a lookup table mapping `player_id` to `team_id` within each game.
5. Filter raw game events to include only those occurring before the specified cutoff time.
6. Select relevant event types: `player_kill`, `drake_kill`, `rift_herald_kill`, `tower_kill`.
7. Count the occurrences of these selected event types for team1 and team2 in each game, filling missing counts with 0.
8. Calculate difference features (`_diff`) by subtracting team 2's event counts from team 1's counts (e.g., `kill_diff = player_kill_team1 - player_kill_team2`). Replace potential NA values with 0.
9. Identify the first occurrence for kills (blood), dragons, heralds, and towers before the cutoff time.
10. Determine which team (`team1`, `team2`, or `none`) secured each first event. Assign `none` if no event occurred or if events were simultaneous (tied timestamp). Record the timestamp (`time_first_*`) for each first event.
11. Join player stats with champion role/type data.
12. Count the number of champions of each type (Fighter, Mage, etc.) for team1 and team2 in each game, filling missing counts with 0.
13. Calculate champion type difference features (`_champdiff`) by subtracting team 2's champion type counts from team 1's counts.
14. Combine `game_id`, team IDs, `team1_won`, all `_diff` features, all `first_` features, all `time_first_*` features, and all `_champdiff` features into the final dataset structure.
15. Convert `first_` features (e.g., `first_blood`) to factors, replacing any NA values with the level `none`.

### Resulting dataset structure

The final dataset will have one row per `game_id`. Each row represents the state
of a game after `N` minutes, along with the final outcome. Columns will include:

*   `game_id`: Unique game identifier.
*   `team1_id`: Unique identifier for team 1 (arbitrarily assigned as the lower ID).
*   `team2_id`: Unique identifier for team 2 (arbitrarily assigned as the higher ID).
*   `team1_won`: Numeric target variable (1 if team 1 won, 0 otherwise).
*   `kill_diff`: Numeric difference (team 1 kills - team 2 kills) at `N` minutes.
*   `dragon_diff`: Numeric difference (team 1 dragons - team 2 dragons) at `N` minutes.
*   `rift_herald_diff`: Numeric difference (team 1 heralds - team 2 heralds) at `N` minutes.
*   `tower_diff`: Numeric difference (team 1 towers - team 2 towers) at `N` minutes.
*   `first_blood`: Factor indicating which team got the first kill ('team1', 'team2', 'none' if tied or no kill before `N min).
*   `time_first_blood`: Numeric time (in seconds) when the first blood occurred (NA if none before `N` min or tied).
*   `first_dragon`: Factor indicating which team got the first dragon ('team1', 'team2', 'none' if tied or no dragon before N min).
*   `time_first_dragon`: Numeric time (in seconds) when the first dragon occurred (NA if none before `N` min or tied).
*   `first_herald`: Factor indicating which team got the first herald ('team1', 'team2', 'none' if tied or no herald before `N` min).
*   `time_first_herald`: Numeric time (in seconds) when the first herald occurred (NA if none before `N` min or tied).
*   `first_tower`: Factor indicating which team got the first tower ('team1', 'team2', 'none' if tied or no tower before N min).
*   `time_first_tower`: Numeric time (in seconds) when the first tower occurred (NA if none before `N` min or tied).
*   `fighter_champdiff`: Numeric difference (team 1 fighters - team 2 fighters).
*   `mage_champdiff`: Numeric difference (team 1 mages - team 2 mages).
*   `assassin_champdiff`: Numeric difference (team 1 assassins - team 2 assassins).
*   `marksman_champdiff`: Numeric difference (team 1 marksmen - team 2 marksmen).
*   `tank_champdiff`: Numeric difference (team 1 tanks - team 2 tanks).
*   `support_champdiff`: Numeric difference (team 1 supports - team 2 supports).

```{r}
N <- 12 * 60
dataset <- early_game_dataset(player_stats, metadata, events, champs, N)
```

This gives us a dataset containing `r nrow(dataset)` early game states.
With that many matches, we're confident we have large enough dataset. So, we
decided to skip doing a formal power analysis because the sheer amount of data
should be more than enough.

The choice of `N = 12 minutes` is arbitrary, just from our experience of playing
LoL. The definition of "early game" is: The game phase where players focus on
their lanes, and it ends when the first turret in any lane is destroyed. [source](https://gameboost.com/definitions/league-of-legends/early-game)
As can be seen later in EDA, 10 to 12 minutes have the most first towers destroyed.

## Notice on LLM usage

We utilized LLMs for assistance with refining plot styling and brainstorming
visualization ideas presented in this EDA.

## EDA

### Target `team1_won`

```{r}
ggplot(dataset, aes(x = factor(team1_won))) +
    geom_bar(aes(y = after_stat(count)), fill = c(color2, color1)) +
    geom_text(
        aes(y = after_stat(count), label = after_stat(count)),
        stat = "count",
        vjust = -0.5
    ) +
    scale_x_discrete(labels = c("0" = "Team 2 Wins", "1" = "Team 1 Wins")) +
    labs(
        title = "Distribution of game outcomes",
        subtitle = paste("Based on", nrow(dataset), "games"),
        x = "Outcome",
        y = "Number of games"
    ) +
    theme_minimal()
```

The dataset appears reasonably balanced between team 1 and team 2 wins. Around
47% to 53%. The difference is caused by  team 1 being the blue side, which has
an advantage in picking champions before the game, that we can't address.

### Event `_diff` features

```{r fig.width=10}
dataset %>%
    select(ends_with("_diff")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        ggplot(dataset, aes(x = !!col_sym)) +
            geom_histogram(
                binwidth = 1,
                center = 0,
                fill = color1,
                color = "black",
                alpha = 0.8
            ) +
            labs(x = .x, y = "Number of games") +
            theme_minimal()
    }) %>%
    wrap_plots(ncol = 2)
```

The distribution of `kill_diff` seem promising. Just from looking
at it, it appears like a normal distribution. `dragon_diff` suggests that
either there are no diffs, or one team dominates in this metric. And since rift
herald spawns later and is more difficult to kill, thus the diff is only 1 (-1),
there aren't many kills of it in early game. In many games there is no `tower_diff`.

```{r fig.width=12}
dataset %>%
	select(ends_with("_diff")) %>%
	colnames() %>%
	map(~ {
		col_sym <- sym(.x)
		
		dataset %>%
			ggplot(aes(x = factor(team1_won), y = !!col_sym, fill = factor(team1_won))) +
			geom_boxplot(alpha = 0.8, outlier.shape = 21, outlier.size = 1.5) +
			scale_x_discrete(labels = c("0" = "Team 2 Wins", "1" = "Team 1 Wins")) +
			scale_fill_manual(
				values = c("0" = color2, "1" = color1),
				guide = "none"
			) +
			geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
			labs(
				title = paste("Distribution of", .x, "by game outcome"),
				x = "Game outcome",
				y = paste(.x, "(team1 - team2)")
			) +
			theme_minimal()
	}) %>%
	wrap_plots(ncol = 2)
```

Boxes have the same heights for both outcomes of a game, so `_diff` features
have homoscedasticity. Only the `kill_diff` has different distributions, other
diffs are all same for both outcomes of the game.

```{r}
custom_palette <- colorRampPalette(c(color1, "white", color2))(100)

dataset %>%
	select(ends_with("_diff")) %>%
	cor(use = "pairwise.complete.obs") %>%
	corrplot(
		method = "color",
		col = custom_palette,
		type = "upper",
		tl.col = "black",
		tl.srt = 45,
		addCoef.col = "black",
		number.cex = 1,
		diag = F,
		mar = c(0, 0, 1, 0))
```

The correlation matrix seems promising, no strong correlation between `_diff` features.

```{r fig.width=12, fig.height=10}
dataset %>%
	select(ends_with("_diff")) %>%
	colnames() %>%
	map(~ {
		col_sym = sym(.x)
		
		dataset %>%
			ggplot(aes(x = !!col_sym, y = team1_won)) +
			geom_jitter(
				aes(color = factor(team1_won)),
				width = 0,
				height = 0.1, 
				alpha = 0.3,
				size = 1.5) +
			scale_color_manual(
				values = c("0" = color2, "1" = color1),
				labels = c("0" = "team 2 wins", "1" = "team 1 wins"),
				name = "Game Outcome") +
			scale_y_continuous(
				breaks = c(0, 1),
				labels = c("0" = "team 2 wins", "1" = "team 1 wins")) +
			labs(
				title = paste("Relationship between", .x, "and game outcome"),
				x = paste(.x, "(team 1 - team 2)"),
				y = "Game Outcome") +
			theme_minimal() +
			theme(legend.position = "bottom") +
			geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5)
	}) %>%
    wrap_plots(ncol = 2, guides = "collect") &
	theme(legend.position = "bottom")
```

But `_diff` features alone are not enough to predict outcome of a game. Only
`kill_diff` shows some separation but still there is big overlap. Using them
with logistic regression would produce a model with a lot of errors.

### Team compositions diffs

Champions can put in classes like `tank`, `fighter`, `mage` and so on. If there
is an difference in champion types, then maybe there can is some relation to
the win rate of games.

```{r fig.width=12, fig.height=8}
dataset %>%
    select(ends_with("_champdiff")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        
        dataset %>%
        	ggplot(aes(x = !!col_sym)) +
            geom_histogram(
                binwidth = 1,
                center = 0,
                fill = color1,
                color = "black",
                alpha = 0.8) +
            labs(x = .x, y = "Number of games") +
            theme_minimal()}) %>%
    wrap_plots(ncol = 3) +
    plot_annotation(title = "Distribution of champion type diffs (team 1 - team 2)")
```

Well, in all types, the most dominant difference is 0. This makes sense because
during some LoL meta, teams tend to play the same things, so the teams have similiar
team compositions.

```{r fig.width=12, fig.height=8}
dataset %>%
	select(ends_with("_champdiff")) %>%
	colnames() %>%
	map(~ {
		col_sym <- sym(.x)
		
		dataset %>%
			ggplot(aes(x = factor(team1_won), y = !!col_sym, fill = factor(team1_won))) +
			geom_boxplot(alpha = 0.8, outlier.shape = 21, outlier.size = 1.5) +
			scale_x_discrete(labels = c("0" = "Team 2 Wins", "1" = "Team 1 Wins")) +
			scale_fill_manual(
				values = c("0" = color2, "1" = color1),
				guide = "none"
			) +
			geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
			labs(
				title = paste("Distribution of", .x, "by game outcome"),
				x = "Game outcome",
				y = .x
			) +
			theme_minimal()
	}) %>%
	wrap_plots(ncol = 2)
```		

Distributions of champion diffs don't suggest anything useful. Boxplots
show minimal separation between winning and losing outcomes based on champion
class differences. We won't be exploring these features as we think the analysis
up this point proves they are not relevant.

### `first_` features

#### Distributions

```{r fig.width=10}
dataset %>%
    select(starts_with("first_")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        
        dataset %>%
        	ggplot(aes(x = !!col_sym)) +
            geom_bar(aes(fill = !!col_sym), stat = "count", alpha = 0.8) +
            geom_text(
                aes(label = after_stat(count)),
                stat = "count",
                vjust = -0.5
            ) +
            scale_fill_manual(
            	values = c("team1" = color1, "team2" = color2, "none" = "grey"),
                guide = "none") +
            labs(y = NULL) +
            theme_minimal()
    }) %>%
    wrap_plots(ncol = 4)
```

If an `first_` event occurred in the early game, then it is around 50/50 split
between team 1 and team 2 achieving it. `first_tower` didn't happen in
`r percent(sum(dataset$first_tower == 'none') / nrow(dataset), accuracy = 1)` of games.

#### Securing `first_` event and winning a game

```{r fig.width=12, fig.height=6}
# inspired by https://rpubs.com/stephenmoore56/345708 and
# https://stackoverflow.com/questions/48086575/ggplot2-problems-with-using-prop-and-grouping-bar-graph-by-another-categor
dataset %>%
    select(starts_with("first_")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        
        dataset %>%
        	mutate(team1_won = factor(
        		team1_won,
        		levels = c(0, 1),
        		labels = c("team 2 wins", "team 1 wins")
        	)) %>%
        	count(!!col_sym, team1_won, name = "n") %>%
        	group_by(!!col_sym) %>%
        	mutate(prop = n / sum(n)) %>%
        	ungroup() %>%
        	ggplot(aes(x = !!col_sym, y = prop, fill = team1_won)) +
        	geom_col(position = position_dodge(preserve = "single")) +
        	geom_text(
        		aes(label = percent(prop, accuracy = .1)),
        		position = position_dodge(width = 1),
        		vjust = -0.5,
        		size = 4) +
        	scale_y_continuous(labels = percent_format(accuracy = .1)) +
        	scale_fill_manual(values = c("team 1 wins" = color1, "team 2 wins" = color2)) +
        	labs(y = "Proportion of games", fill = "Game outcome") +
        	theme_minimal()
    }) %>%
    wrap_plots(ncol = 4, guides = "collect") &
	theme(legend.position = "bottom")
```

If a team secured a `first_` event, it won in a majority of games. However the
difference between securing the event and winning the game per team are not
balanced. If a team 1 secured `first_blood`, in 63.9% games it won, but if
if team 2 secured it, they won only in 58.2% games. Same goes for other `first_`
features. It has to do with the fact that team 1 is on the blue side, and
has an advantage in picking champions before the game that we can't address. The
`first_tower` has the highest value, if a team 1 secured it they won in 73.4%
games and team 2 in 69.3% of games. But `first_tower` happened only in
`r percent(1 - sum(dataset$first_tower == 'none') / nrow(dataset), accuracy = 1)`
of games.

#### Timings of `first_` features

```{r fig.width=10}
dataset %>%
	select(starts_with("time_first_")) %>%
	colnames() %>%
	map(~ {
        col_sym <- sym(.x)
        
        dataset %>%
        	filter(!is.na(!!col_sym)) %>%
        	select(!!col_sym) %>%
        	ggplot(aes(x = !!col_sym / 60)) +
        	geom_histogram(binwidth = 1, fill = color1, color = "black", alpha = 0.8) +
        	labs(
        		title = paste("Distribution of", .x),
        		x = "Time (minutes)",
        		y = "Number of games") +
        	theme_minimal()
	}) %>%
    wrap_plots(ncol = 2)
```

These graphs only reflect known timings of the game, which is a good sanity check.

```{r fig.width=12, fig.height=10}
first_to_times <- list(
	first_blood = "time_first_blood",
	first_dragon = "time_first_dragon",
	first_herald = "time_first_herald",
	first_tower = "time_first_tower")

first_to_times %>%
	imap(~ {
		first_col_sym <- sym(.y)
		time_col_sym <- sym(.x)
		
		dataset %>%
			filter(!!first_col_sym != "none") %>%
			mutate(
				time_bin = cut(
					!!time_col_sym,
					breaks = seq(0, N, by = 60),
					include.lowest = TRUE,
					right = FALSE),
				first_team_won = case_when(
					!!first_col_sym == "team1" & team1_won == 1 ~ TRUE,
					!!first_col_sym == "team2" & team1_won == 0 ~ TRUE,
					TRUE ~ FALSE)) %>%
			group_by(time_bin) %>%
			summarise(
				n_games = n(),
				win_rate = mean(first_team_won, na.rm = TRUE)) %>%
			filter(!is.na(time_bin)) %>%
			ggplot(aes(x = time_bin, y = win_rate)) +
			geom_col(fill = color1, alpha = 0.8) +
			geom_text(aes(label = percent(win_rate, accuracy = 0.1)), vjust = -0.5) +
			scale_y_continuous(labels = percent_format(), limits = c(0, 1)) +
			labs(
				title = paste("Win rate for team securing", .y),
				x = paste("Time bin when", .y, "occured"),
			) +
			theme_minimal()
	}) %>%
    wrap_plots(ncol = 1)
```

Timings of the `first_` events doesn't tell us anything new, that only when a
team secures some first event they tend to have above average win rate. For the
most counted player kill event, it doesn't matter if `first_blood` happens
at the start of at the end of early game, securing team still has same win rate.
The `first_tower` can be relied on, since it happens in less than 20% of games.


#### Relationship between the `first_` features

```{r fig.width=12, fig.height=10}
# inspired by https://haleyjeppson.github.io/ggmosaic/
dataset %>%
	select(starts_with("first_")) %>%
	colnames() %>%
	combn(2, simplify = F) %>%
	map(~ {
		var1 <- .x[1]
		var2 <- .x[2]
		sym1 <- sym(var1)
		sym2 <- sym(var2)
		
		dataset %>%
			filter(!!sym1 != "none", !!sym2 != "none") %>%
			# removes none from axis
			mutate(
				!!var1 := factor(!!sym1, levels = c("team1", "team2")),
				!!var2 := factor(!!sym2, levels = c("team1", "team2"))) %>%
			ggplot() +
			geom_mosaic(
				aes(x = product(!!sym1, !!sym2), fill = !!sym1),
				alpha = 0.8,
				color = "white") +
			geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 0.5) +
			scale_fill_manual(
				values = c("team1" = color1, "team2" = color2),
				guide = "none") +
			labs(title = paste(var1, "and", var2)) +
			theme_minimal() +
			theme(
				plot.title = element_text(size = 10),
				axis.text.x = element_text(angle = 45, hjust = 1)
			)
	}) %>%
	wrap_plots(ncol = 3)
```

These plots show the relationships between the 4 `first_` features. If a team
achieved event number 1, then in what portion of games did they achieve the
event number 2 (event number 1 and event number 2, e.g. `first_blood` and `first_herald`).
Only the `first_herald` and `first_tower` have significant relationship, that is
because herald's purpose is to get the first tower of the game.

### Relationships between `first_`s and `_diff`s

```{r fig.width=12, fig.height=8}
direct_rels <- list(
	first_blood = "kill_diff",
	first_dragon = "dragon_diff",
	first_herald = "rift_herald_diff",
	first_tower = "tower_diff")

direct_rels  %>%
	imap(~ {
		first_col_sym <- sym(.y)
		diff_col_sym <- sym(.x)
		
		dataset %>%
			filter(!!first_col_sym != "none") %>%
			ggplot(aes(x = !!diff_col_sym, fill = !!first_col_sym, color = !!first_col_sym)) +
			geom_area(
				stat = "bin",
				binwidth = 1,
				position = "identity",
				alpha = 0.4) +
			scale_fill_manual(
				values = c("team1" = color1, "team2" = color2),
				name = .y) +
			scale_color_manual(
				values = c("team1" = color1, "team2" = color2),
				name = .y) +
			labs(
				title = paste0("Distribution of '", .x, "' by '", .y, "'"),
				x = paste(.x, "(team1 - team2)"),
				y = "Number of games") +
			geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
			theme_minimal() +
			theme(legend.position = "bottom")
	}) %>%
	wrap_plots(ncol = 2)
```

From these graphs we can see that if a team secured `first_` event, then it
was leading at the end of the early game in a `_diff` of that event. But all
except `kill_diff` have small ranges, only the `kill_diff` has bigger value range,
but there is big overlap between distributions of it.

#### Influence of `first_` on win rate with respect to `_diff`

At the end of the early game, `_diff` features can be in 3 states:

1. **0** - no team has lead in this event diff
2. **> 0** - team 1 has lead
3. **< 0** - team 2 has lead

Following graphs show what advantage (or disadvantage) achieving `first_` event
has on the win rate, with respect to each of the 3 states corresponding `_diff`
can be in.

```{r fig.width=12, fig.height=20}
direct_rels %>%
	imap(~ {
		first_col_sym <- sym(.y)
		diff_col_sym <- sym(.x)
		
		dataset %>%
			mutate(diff_sign = case_when(
				!!diff_col_sym > 0 ~ "team1 lead",
				!!diff_col_sym < 0 ~ "team2 lead",
				TRUE ~ "diff zero"
			)) %>%
			mutate(team1_won = factor(
				team1_won,
				levels = c(0, 1),
				labels = c("team 2 wins", "team 1 wins")
			)) %>%
			count(!!first_col_sym, diff_sign, team1_won, name = "n") %>%
			group_by(!!first_col_sym, diff_sign) %>%
			mutate(prop = n / sum(n)) %>%
			ungroup() %>%
			ggplot(aes(x = !!first_col_sym, y = prop, fill = team1_won)) +
			geom_col(position = position_dodge(preserve = "single")) +
			geom_text(
				aes(label = percent(prop, accuracy = .1)),
				position = position_dodge(width = 0.9),
				vjust = -0.5,
				size = 3) + 
			facet_wrap(~diff_sign) +
			scale_y_continuous(labels = percent_format(accuracy = .1)) +
			scale_fill_manual(values = c("team 1 wins" = color1, "team 2 wins" = color2)) +
			labs(
				title = paste("Win rate by", .y),
				subtitle = paste("Faceted by", .x, "sign at the end of early game"),
				x = .y,
				y = "Proportion of games",
				fill = "Game outcome") +
			theme_minimal(base_size = 9) + # Adjust base size if needed
			theme(legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1))
	}) %>%
	wrap_plots(ncol = 1)
```

All of the pairs show that achieving a `first_` event doesn't provide
an advantage big enough to negate that the team is behind in corresponding `_diff`.

If team 1 has kill lead at the end of an early game, then achieving `first_blood`
only gave them around 5% more win rate, same goes for team 2. Dragon and herald
graphs don't have all the cases covered, since these are low range values, there
aren't as many drake and herald kills in the early game as compared to kills.
The tower diff and `first_tower` have some of the strongest win rate indicators,
but tower kills are rare, only happening in less than 20% of games.


### Findings

| Requirement                 | EDA findings                                                                                                                                                                                                                                                                                                                          |
| :-------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Response variable**       | `team1_won` is binary (0 or 1), suitable for classification. Reasonably balanced (~53% vs 47%).                                                                                                                                                                                                                                       |
| **Predictor independence**  | Each row represents a unique game; assuming games are independent events, this requirement holds.                                                                                                                                                                                                                                     |
| **`_diff` Features**        | Numeric differences in objectives. `kill_diff` shows the most separation by outcome. Others have smaller ranges. Generally symmetric distributions, low internal correlation.                                                                                                                                                         |
| **`first_*` Features**      | Categorical (team1/team2/none). Securing any `first_` objective correlates with >50% win rate. `first_tower` is rare (`r percent(1 - sum(dataset$first_tower == 'none') / nrow(dataset), accuracy = 1)` occurrence). Low internal correlation except `first_herald`/`first_tower`.                                            |
| **`time_first_*` Features** | Numeric timestamps. Distributions reflect known game timings (e.g., dragon post-5min). Binned win rate analysis shows timing doesn't significantly alter win probability compared to _if_ the objective was secured. Low independent predictive value observed.                                                             |
| **`_champdiff` Features**   | Numeric differences in champion classes. Distributions centered at 0, small range. Show minimal separation by outcome individually. Low-to-moderate internal correlations.                                                                                                                                                            |
| **Collinearity**            | Low correlation observed between `_diff` features. Low correlation between most `first_*` features (except herald/tower). `_champdiff` features show some expected negative correlations but no high multicollinearity detected. Some correlation exists between related `_diff` and `first_*` (e.g., `kill_diff` and `first_blood`). |
| **Normality**               | `_diff` features are roughly symmetric, `kill_diff` somewhat resembles normal. `first_*` are categorical. `_champdiff` are discrete, centered at 0.                                                                                                                                      |
| **Feature scaling**         | Ranges of `_diff` and `_champdiff` features are relatively small.                                                                                                                                                                                           |
| **Homoscedasticity**        | `_diff` and `_champdiff` features generally show similar variance across `team1_won` groups (homoscedasticity mostly holds for numeric predictors).
| **Outliers**                | EDA didn't reveal extreme, influential outliers in numeric features that would require special handling.                                                                                                                                                                                                           |
| **Sample size**             | Dataset has `r I(nrow(dataset))` games, which is a substantial sample size, providing good statistical power.                                                                                                                                                                                                                         |
| **Linear relationship**     | `_diff` features show some trends with the outcome. `first_*` features show clear steps in win probability. `_champdiff` and `time_first_*` features show weaker individual relationships with the outcome.                                                  |

