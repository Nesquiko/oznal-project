---
title: "Project"
author: "Lukáš Častven, Michal Kilian"
date: "`r Sys.Date()`"
output: html_document
---



# TODO 
- ASK if is ok that our model is accurate max 70%, we could 
	predict game based on the whole game player stats, but we thought that
	this would more fun and more challenging.
- some notice that we used LLMs to style the grapsh and to brainstorm
- explain the creation of the dataset
	- how does the raw data look like
	- add champions dataset to the online dataset links
	- add champions raw dataset description
	- add champions data to the resulting dataset description
	- how we created the dataset, go through the dataset.R file and describe that, e.g.:
		- where are NA
		- how other attributes were transformed
	- in hypothesis specify that we want to classify
	- perform power analysis after creating dataset
	

# Predicting LoL game winner

League of Legends (LoL) is a 5v5 multiplayer online battle arena (MOBA) game.
Teams compete to destroy the enemy's base structure, the Nexus.

Our project goal is to predict the winning team based on events occurring within
the first `N` minutes of professional matches.


## Dataset

The dataset consists of three CSV files: `game_metadata.csv`, `game_players_stats.csv`,
and `game_events.csv`. The fields `game_id` and `player_id` link these files.

### Source

The dataset contains detailed statistics and events from professional LoL matches (2019-2024).
It was published on
[IEEE DataPort under a CC license](https://ieee-dataport.org/documents/league-legends-esports-player-game-data-2019-2024). 
However, since IEEE is a greedy corporation, accessing it there requires a paid subscription.

We obtained the identical dataset directly from the authors' GitHub repository
([PandaScore/PandaSkill](https://github.com/PandaScore/PandaSkill)). This source
provides the data under the permissive MIT license.

### `game_metadata.csv`

This file contains general information about each game.

*   `game_id`: Unique game identifier.
*   `date`: Game date and time in format YYYY-MM-DD HH:MM:SS.ssssss.
*   `match_id`: Identifier for the match (e.g., a best-of-5 series).
*   `tournament_id`: Unique tournament identifier.
*   `tournament_name`: Name of the tournament.
*   `series_id`: Unique series identifier.
*   `series_name`: Name of the series (e.g., LCK Summer 2024).
*   `league_id`: Unique league identifier.
*   `league_name`: Name of the league (e.g., LCK).
*   *Note:* Games belong to matches, matches to tournaments, tournaments to series, and series to leagues.

### `game_players_stats.csv`

This file provides player statistics at the end of each game.

*   `game_id`: Unique game identifier.
*   `player_id`: Unique player identifier.
*   `player_name`: Player's in-game name.
*   `team_id`: Unique team identifier.
*   `team_name`: Name of the player's team.
*   `team_acronym`: Team's acronym.
*   `role`: Player's role (e.g., Mid).
*   `win`: Binary indicator (1 if player won, 0 otherwise).
*   `game_length`: Duration of the game in seconds.
*   `champion_name`: Name of the champion played.
*   `team_kills`: Total champion kills by the player's team.
*   `tower_kills`: Total tower kills by the player's team.
*   `inhibitor_kills`: Total inhibitor kills by the player's team.
*   `dragon_kills`: Total dragon kills by the player's team.
*   `herald_kills`: Total Rift Herald kills by the player's team.
*   `baron_kills`: Total Baron Nashor kills by the player's team.
*   `player_kills`: Player's champion kills.
*   `player_deaths`: Player's deaths.
*   `player_assists`: Player's assists.
*   `total_minions_killed`: Player's minion kills (CS).
*   `gold_earned`: Player's total gold earned.
*   `level`: Player's final champion level.
*   `total_damage_dealt`: Player's total damage dealt.
*   `total_damage_dealt_to_champions`: Player's damage dealt to enemy champions.
*   `total_damage_taken`: Player's total damage taken.
*   `wards_placed`: Player's number of wards placed.
*   `largest_killing_spree`: Player's largest killing spree count.
*   `largest_multi_kill`: Player's largest multi-kill count (e.g., 2 for double kill).

### `game_events.csv`

This file contains specific events occurring during each game.

*   `game_id`: Unique game identifier.
*   `timestamp`: Time in seconds when the event occurred.
*   `event_type`: Type of event (e.g., `player_kill`, `drake_kill`).
*   `killer_id`: ID of the player who got the kill (if applicable).
*   `killed_id`: ID of the player/unit killed (if applicable).
*   `assisting_player_ids`: List of IDs of assisting players (for kills).
*   `drake_type`: Type of dragon killed (e.g., infernal, cloud).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls())

library(tidyverse)
library(tidymodels)
library(patchwork)
library(corrplot)
library(scales)
library(ggmosaic)
library(rpart)
library(rpart.plot)
library(caret)
source("./dataset.R")

metadata <- read_csv("data/game_metadata.csv", show_col_types = F)
player_stats <- read_csv("data/game_players_stats.csv", show_col_types = F)
events <- read_csv("data/game_events.csv", show_col_types = F)
champs <- read_csv("data/260225_LoL_champion_data.csv", show_col_types = F) %>%
	rename(name = `...1`) 

color1 <- "plum"
color2 <- "#A0DDA1"
```

## Hypothesis

We hypothesize that if a team has more kills (player, tower, dragon) in early game
(events that happen before `N`th minute), then they are more likely to win the whole
game.

## Representing early game state

We will create features representing the relative advantage between the two teams at the
`N` minute. This involves calculating the difference in key objectives (kills,
dragons, heralds, towers, voidgrubs) and identifying which team secured the first
significant event (first blood, first dragon, first herald).

### Steps

1.  **Identify teams:** For each `game_id`, determine the two competing `team_id`s from `player_stats`.
	Assign one as `team1_id` and the other as `team2_id`.
2.  **Determine winner:** Create the target variable `team1_won` (1 if `team1_id` won, 0 otherwise)
	using the `win` column from `player_stats`.
3.  **Map players to teams:** Create a lookup to find the `team_id` for any `player_id` within a specific `game_id`.
4.  **Filter events by timestamp:** Select events from `game_events.csv` where `timestamp <= N`.
5.  **Filter events by type:** Some events are new or can't happen in early game:
	* Selected events: `player_kill`, `tower_kill`, `drake_kill`, `rift_herald_kill`
	* Non selected:
		*  `baron_nashor_kill`: baron spawns at 20th minute
		*  `inhibitor_kill`: inhibitors are destroyed in late game
		*  `suicide`: doesn't occur
		*  `other`: don't what they are
		*  `resurrection`: mechanic that is new in the game, doesn't occur
		*  `voidgrub_kill`: introduced recently, doesn't occur in older games
5.  **Calculate features:** For each `game_id`, using the filtered events and player-team mapping:
    *   Calculate the difference in kills between teams.
    *   Calculate the difference in dragon kills.
    *   Calculate the difference in Rift Herald kills.
    *   Calculate the difference in towers destroyed.
    *   Calculate the difference in voidgrubs kills.
    *   Identify which team achieved first blood.
    *   Identify which team took the first dragon.
    *   Identify which team took the first herald.
6.  **Combine data:** Aggregate these features by `game_id` and join them with the `team1_won` target variable.

### Resulting dataset structure

The final dataset will have one row per `game_id`. Each row represents the state
of a game after `N` minutes, along with the final outcome. Columns will include:

*   `game_id`: Unique game identifier.
*   `kill_diff`: Numeric difference (team 1 kills - team 2 kills).
*   `drake_diff`: Numeric difference (team 1 dragons - team 2 dragons).
*   `herald_diff`: Numeric difference (team 1 heralds - team 2 heralds).
*   `tower_diff`: Numeric difference (team 1 towers - team 2 towers).
*   `grub_diff`: Numeric difference (team 1 grubs - team 2 grubs).
*   `first_blood`: Factor indicating which team got the first kill ('team1', 'team2', 'none').
*   `first_dragon`: Factor indicating which team got the first dragon ('team1', 'team2', 'none').
*   `first_herald`: Factor indicating which team got the first herald ('team1', 'team2', 'none').
*   `team1_won`: Factor or numeric target variable (1 if team 1 won, 0 otherwise).

```{r}
N <- 12 * 60
dataset <- early_game_dataset(player_stats, metadata, events, champs, N)
```

## EDA

### Target `team1_won`

```{r}
ggplot(dataset, aes(x = factor(team1_won))) +
    geom_bar(aes(y = after_stat(count)), fill = c(color1, color2)) +
    geom_text(
        aes(y = after_stat(count), label = after_stat(count)),
        stat = "count",
        vjust = -0.5
    ) +
    scale_x_discrete(labels = c("0" = "Team 2 Wins", "1" = "Team 1 Wins")) +
    labs(
        title = "Distribution of game outcomes",
        subtitle = paste("Based on", nrow(dataset), "games"),
        x = "Outcome",
        y = "Number of games"
    ) +
    theme_minimal()
```

The dataset appears reasonably balanced between team 1 and team 2 wins. Around
47% to 53%. The difference is caused by  team 1 being the blue side, which has
an advantage in picking champions before the game, that we can't address.

### Event `_diff` features

```{r fig.width=10}
dataset %>%
    select(ends_with("_diff")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        ggplot(dataset, aes(x = !!col_sym)) +
            geom_histogram(
                binwidth = 1,
                center = 0,
                fill = color1,
                color = "black",
                alpha = 0.8
            ) +
            labs(x = .x, y = "Number of games") +
            theme_minimal()
    }) %>%
    wrap_plots(ncol = 2)
```

Distributions of `kill_diff` and `tower_diff` seem promising. Just from looking
at them, they appear like a normal distributions. `dragon_diff` suggests that
either there are no diffs, or one team dominates in this metric. And since rift
herald spawns later and is more difficult to kill, thus the diff is only 1 (-1),
there aren't many kills of it in early game.

```{r fig.width=12}
dataset %>%
	select(ends_with("_diff")) %>%
	colnames() %>%
	map(~ {
		col_sym <- sym(.x) # Convert string name to symbol
		
		ggplot(dataset, aes(x = factor(team1_won), y = !!col_sym, fill = factor(team1_won))) +
			geom_boxplot(alpha = 0.8, outlier.shape = 21, outlier.size = 1.5) +
			scale_x_discrete(labels = c("0" = "Team 2 Wins", "1" = "Team 1 Wins")) +
			scale_fill_manual(
				values = c("0" = color2, "1" = color1),
				guide = "none"
			) +
			geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
			labs(
				title = paste("Distribution of", .x, "by game outcome"),
				x = "Game outcome",
				y = paste(.x, "(team1 - team2)")
			) +
			theme_minimal()
	}) %>%
	wrap_plots(ncol = 2)
```

Boxes are have the same heights for both outcomes of a game, so `_diff` features
have homoscedasticity.

```{r}
custom_palette <- colorRampPalette(c(color1, "white", color2))(100)

dataset %>%
	select(ends_with("_diff")) %>%
	cor(use = "pairwise.complete.obs") %>%
	corrplot(
		method = "color",
		col = custom_palette,
		type = "upper",
		tl.col = "black",
		tl.srt = 45,
		addCoef.col = "black",
		number.cex = 1,
		diag = F,
		mar = c(0, 0, 1, 0))
```

The correlation matrix seems promising, no strong correlation between `_diff` features.

```{r fig.width=12, fig.height=10}
dataset %>%
	select(ends_with("_diff")) %>%
	colnames() %>%
	map(~ {
		col_sym = sym(.x)
		
		dataset %>%
			ggplot(aes(x = !!col_sym, y = team1_won)) +
			geom_jitter(
				aes(color = factor(team1_won)),
				width = 0,
				height = 0.1, 
				alpha = 0.3,
				size = 1.5) +
			scale_color_manual(
				values = c("0" = color1, "1" = color2),
				labels = c("0" = "team 2 wins", "1" = "team 1 wins"),
				name = "Game Outcome") +
			scale_y_continuous(
				breaks = c(0, 1),
				labels = c("0" = "team 2 wins", "1" = "team 1 wins")) +
			labs(
				title = paste("Relationship between", .x, "and game outcome"),
				x = paste(.x, "(team 1 - team 2)"),
				y = "Game Outcome") +
			theme_minimal() +
			theme(legend.position = "bottom") +
			geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5)
	}) %>%
    wrap_plots(ncol = 2, guides = "collect") &
	theme(legend.position = "bottom")
```

But `_diff` features alone are not enough to predict outcome of a game. They
have big overlaps, using them with logistic regression would produce a model
with a lot of errors.

### Team compositions diffs

```{r fig.width=12}
dataset %>%
	select(ends_with("_champdiff")) %>%
	colnames() %>%
	map(~ {
		col_sym <- sym(.x) # Convert string name to symbol
		
		ggplot(dataset, aes(x = factor(team1_won), y = !!col_sym, fill = factor(team1_won))) +
			geom_boxplot(alpha = 0.8, outlier.shape = 21, outlier.size = 1.5) +
			scale_x_discrete(labels = c("0" = "Team 2 Wins", "1" = "Team 1 Wins")) +
			scale_fill_manual(
				values = c("0" = color2, "1" = color1),
				guide = "none"
			) +
			geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
			labs(
				title = paste("Distribution of", .x, "by game outcome"),
				x = "Game outcome",
				y = .x
			) +
			theme_minimal()
	}) %>%
	wrap_plots(ncol = 2)
```		

These champion type diffs are useless, so we will remove them from dataset

```{r}
dataset <- dataset %>% select(!ends_with("_champdiff"))
```

### `first_` features

#### Distributions

```{r fig.width=10}
dataset %>%
    select(starts_with("first_")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        
        dataset %>%
        	ggplot(aes(x = !!col_sym)) +
            geom_bar(aes(fill = !!col_sym), stat = "count", alpha = 0.8) +
            geom_text(
                aes(label = after_stat(count)),
                stat = "count",
                vjust = -0.5
            ) +
            scale_fill_manual(
            	values = c("team1" = color1, "team2" = color2, "none" = "grey"),
                guide = "none") +
            labs(y = NULL) +
            theme_minimal()
    }) %>%
    wrap_plots(ncol = 4)
```

If an `first_` event occurred in the early game, then it is around 50/50 split
between team 1 and team 2 achieving it.

#### Securing `first_` event and winning a game

```{r fig.width=12, fig.height=5}
# inspired by https://rpubs.com/stephenmoore56/345708 and
# https://stackoverflow.com/questions/48086575/ggplot2-problems-with-using-prop-and-grouping-bar-graph-by-another-categor
dataset %>%
    select(starts_with("first_")) %>%
    colnames() %>%
    map(~ {
        col_sym <- sym(.x)
        
        dataset %>%
        	filter(!!col_sym != "none") %>%
        	mutate(team1_won = factor(
        		team1_won,
        		levels = c(0, 1),
        		labels = c("Team 2 Wins", "Team 1 Wins")
        	)) %>%
        	count(!!col_sym, team1_won, name = "n") %>%
        	group_by(!!col_sym) %>%
        	mutate(prop = n / sum(n)) %>%
        	ungroup() %>%
        	ggplot(aes(x = !!col_sym, y = prop, fill = team1_won)) +
        	geom_col(position = position_dodge(preserve = "single")) +
        	geom_text(
        		aes(label = percent(prop, accuracy = .1)),
        		position = position_dodge(width = 1),
        		vjust = -0.5,
        		size = 4) +
        	scale_y_continuous(labels = percent_format(accuracy = .1)) +
        	scale_fill_manual(values = c("Team 1 Wins" = color1, "Team 2 Wins" = color2)) +
        	labs(y = "Proportion of games", fill = "Game outcome") +
        	theme_minimal()
    }) %>%
    wrap_plots(ncol = 4, guides = "collect") &
	theme(legend.position = "bottom")
```

If a team secured a `first_` event, it won in a majority of games. However the
difference between securing the event and winning the game per team are not
balanced. If a team 1 secured `first_blood` in 63.8% games it wind, but if
if team 2 secures it, they win only in 58.2% games. Same goes for other `first_`
features. It has to do with the fact that team 1 is on the blue side, and
has an advantage in picking champions before the game that we can't address.

#### Relationship between the `first_` features

```{r fig.width=12, fig.height=10}
# inspired by https://haleyjeppson.github.io/ggmosaic/
dataset %>%
	select(starts_with("first_")) %>%
	colnames() %>%
	combn(2, simplify = F) %>%
	map(~ {
		var1 <- .x[1]
		var2 <- .x[2]
		sym1 <- sym(var1)
		sym2 <- sym(var2)
		
		dataset %>%
			filter(!!sym1 != "none", !!sym2 != "none") %>%
			mutate(
				!!var1 := factor(!!sym1, levels = c("team1", "team2")),
				!!var2 := factor(!!sym2, levels = c("team1", "team2"))) %>%
			ggplot() +
			geom_mosaic(
				aes(x = product(!!sym1, !!sym2), fill = !!sym1),
				alpha = 0.8,
				color = "white") +
			geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 0.5) +
			scale_fill_manual(
				values = c("team1" = color1, "team2" = color2),
				guide = "none") +
			labs(
				title = paste(var1, "vs", var2),
				x = "",
				y = "") +
			theme_minimal() +
			theme(
				plot.title = element_text(size = 10),
				axis.text.x = element_text(angle = 45, hjust = 1)
			)
	}) %>%
	wrap_plots(ncol = 3)
```

These plots show the relationships between the 4 `first_` features. If a team
achieved event number 1, then in what portion of games did they achieve the
event number 2 (event number 1 vs event number 2, e.g. `first_blood` vs `first_herald`).
Only the `first_herald` vs `first_tower` have significant relationship, that is
because herald's purpose is to get the first tower of the game.

### Relationships between `first_`s and `_diff`s

```{r fig.width=12, fig.height=8}
direct_rels <- list(
	first_blood = "kill_diff",
	first_dragon = "dragon_diff",
	first_herald = "rift_herald_diff",
	first_tower = "tower_diff")

direct_rels  %>%
	imap(~ {
		first_col_sym <- sym(.y)
		diff_col_sym <- sym(.x)
		
		dataset %>%
			filter(!!first_col_sym != "none") %>%
			ggplot(aes(x = !!diff_col_sym, fill = !!first_col_sym, color = !!first_col_sym)) +
			geom_area(
				stat = "bin",
				binwidth = 1,
				position = "identity",
				alpha = 0.4) +
			scale_fill_manual(
				values = c("team1" = color1, "team2" = color2),
				name = .y) +
			scale_color_manual(
				values = c("team1" = color1, "team2" = color2),
				name = .y) +
			labs(
				title = paste0("Distribution of '", .x, "' by '", .y, "'"),
				x = paste(.x, "(team1 - team2)"),
				y = "Number of games") +
			geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.5) +
			theme_minimal() +
			theme(legend.position = "bottom")
	}) %>%
	wrap_plots(ncol = 2)
```
From these graphs we can see that if a team secured `first_` event, then in it
was leading at the end of the early game in a `_diff` of that event.

#### Influence of `first_` on win rate with respect to `_diff`

At the end of the early game, `_diff` features can be in 3 states:

1. **0** - no team has lead in this event diff
2. **> 0** - team 1 has lead
3. **< 0** - team 2 has lead

Following graphs show what advantage (or disadvantage) achieving `first_` event
has on the win rate, with respect to each of the 3 states corresponding `_diff`
can be in.

```{r fig.width=12, fig.height=20}
direct_rels %>%
	imap(~ {
		first_col_sym <- sym(.y)
		diff_col_sym <- sym(.x)
		
		dataset %>%
			mutate(diff_sign = case_when(
				!!diff_col_sym > 0 ~ "team1 lead",
				!!diff_col_sym < 0 ~ "team2 lead",
				TRUE ~ "diff zero"
			)) %>%
			filter(!!first_col_sym != "none") %>%
			mutate(team1_won = factor(
				team1_won,
				levels = c(0, 1),
				labels = c("team 2 wins", "team 1 wins")
			)) %>%
			count(!!first_col_sym, diff_sign, team1_won, name = "n") %>%
			group_by(!!first_col_sym, diff_sign) %>%
			mutate(prop = n / sum(n)) %>%
			ungroup() %>%
			ggplot(aes(x = !!first_col_sym, y = prop, fill = team1_won)) +
			geom_col(position = position_dodge(preserve = "single")) +
			geom_text(
				aes(label = percent(prop, accuracy = .1)),
				position = position_dodge(width = 0.9),
				vjust = -0.5,
				size = 3) + 
			facet_wrap(~diff_sign) +
			scale_y_continuous(labels = percent_format(accuracy = .1)) +
			scale_fill_manual(values = c("team 1 wins" = color1, "team 2 wins" = color2)) +
			labs(
				title = paste("Win rate by", .y),
				subtitle = paste("Faceted by", .x, "sign at the end of early game"),
				x = .y,
				y = "Proportion of games",
				fill = "Game outcome") +
			theme_minimal(base_size = 9) + # Adjust base size if needed
			theme(legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1))
	}) %>%
	wrap_plots(ncol = 1)
```

All of the pairs show that achieving a `first_` event doesn't provide
an advantage big enough to negate that the team is behind in corresponding `_diff`.
`first_blood` with respect to `kill_diff` and `first_tower` with respect to `tower_diff`
have all 12 possible cases covered, so we think they might be useful in our model.

### Findings

| Requirement                | EDA findings                                                                                                                                                           |
| :------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Response variable**      | `team1_won` is binary (0 or 1).                                                                                                                                        |
| **Predictor independence** | Each row is a unique game, which are independent events.                                                                                                               |
| **Collinearity**           | `_diff` features show low correlation among themselves. `first_*` features low (except herald/tower). Some correlation expected between related `_diff` and `first_*`. |
| **Normality**              | `kill_diff` and `tower_diff` distributions resemble normal distributions. `first_*` features are categorical.                                                          |
| **Feature scaling**        | Ranges of `_diff` features are relatively small (mostly within [-15, 15]). Testing needed to see if scaling improves model performance.                                |
| **Homoscedasticity**       | `_diff` features generally show similar variance across `team1_won` groups (homoscedasticity mostly holds for numeric predictors).                                     |
| **Outliers**               | EDA didn't reveal extreme outliers in `_diff` features.                                                                                                                |
| **Sample size**            | Dataset has `r I(nrow(dataset))` games, which is a substantial sample size.                                                                                            |
| **Linear relationship**    | `_diff` features show some monotonic trends with the outcome (log-odds).                                                                                               |

Based on these EDA findings, as of our first model we choose simple decision trees.
We think our dataset isn't complex one, few integers on small ranges and few
categorical features.

## Decision trees

```{r}
data <- dataset %>% mutate(team1_won = factor(team1_won))

train_indices <- createDataPartition(data$team1_won, p = 0.8, list = FALSE, times = 1)
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]

set.seed(42069) 
tree_control <- rpart.control(maxdepth = 10, cp = 0.001)
simple_tree_model <- rpart(
  team1_won ~ .,
  data = train_data,
  method = "class",
  control = tree_control)

predictions <- predict(simple_tree_model, newdata = test_data, type = "class")
conf_matrix <- confusionMatrix(predictions, test_data$team1_won)
print(conf_matrix)
```






















